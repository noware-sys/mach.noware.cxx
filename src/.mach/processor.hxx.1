/*
#pragma once
//#ifndef __PROCESSOR
//#define __PROCESSOR

// Standard:
#include <string>
#include <queue>
//#include <stack>
#include <mutex>
#include <condition_variable>

// Boost:
//#include <boost/thread/mutex.hpp>
//#include <boost/thread/condition_variable.hpp>
#include <boost/serialization/serialization.hpp>

// Boost serialization:
//#include <boost/archive/binary_oarchive.hpp>
//#include <boost/archive/binary_iarchive.hpp>

#include <boost/asio.hpp>
#include <boost/bind.hpp>
#include <boost/thread.hpp>	//
#include <boost/date_time/posix_time/posix_time.hpp>

// This class:
#include "../../default.h++"
#include "../../mathematics.h++"
#include "../../container/array.h++"
#include "../../container/variable.h++"
#include "../../tool.h++"
//#include "../resource.h++"
//#include "memory.h++"
#include "../../cluster/entity.h++"
#include "../../serialization.h++"
#include ".processor/preindex.h++"



namespace LIB
{
	namespace machine
	{
		namespace device
		{
*/			//class processor;
			
			class processor //: /*public */LIB::machine::device
			{
				public:
					//#include ".processor/index.h++"
					
					//class parser
					//{
					//	protected:
					//		// State handlers:
					//		void comment ();

					//		std::queue <LIB::machine::devices::processor::instruction> instructions;
					//	public:
					//		void parse (const std::string, std::queue <LIB::machine::devices::processor::instruction> &);
					//};
					
					enum/* class*/ operation // action operation
					{
						none,
						// For controlling the flow of the execution:
						// and, intersection
						// or, union
						addition,
						substraction,
						multiplication,
						division,
						modulo,
						modulus,
						complement,
						exponentiation,
						assignment,
						//jump,
						output	// output set echo
					};
					
					//class queue
					//{
					//	protected:
					//		friend class boost::serialization::access;
					//		// friend std::ostream & operator << (std::ostream &, const instruction &);

					//		template <typename archive>
					//		void serialize (archive &, const unsigned int);
					//	public:
					//		queue (void);
					//		~queue (void);

					//		std::queue <LIB::machine::devices::processor::instructions> _queue;

					//		operator std::string (void) const;
					//		queue operator = (const std::string &);
					//};

					//class results
					//{
					//	protected:
					//		friend class boost::serialization::access;

					//		template <typename std::string>
					//		void serialize (std::string &/*, const unsigned int version*/);
					//};
					
					#include ".processor/index.h++"
					
					class predicate
					{
						public:
							bool * test;
							
							predicate (void);
							const bool operator() (void) const;
					};
					
				protected:
					std::mutex running_mutex;
					std::condition_variable running_condition_variable;
					
					bool running;
					// bool running, running_main;
					//std::string last_instruction;	// Name of the location of the last instruction which has been enqueued.
					//const std::string next_available_instruction_location (void) const;	// Get the next available name for an instruction.
					//const std::string next_available_instruction (void) const;	// Get the next available name for an instruction.
					
					// boost::mutex running_mutex;
					// boost::condition_variable running_condition_variable;
					
					void perform (void);
					const bool execute (const instruction &);
					void pause (void) const;
					
					//LIB::NAME_A <core, boost::thread::id> cores;
					//LIB::NAME_A <core, LIB::mathematics::numbers::natural> cores;
				//	LIB::container::NAME_A <boost::thread (boost::bind (& LIB::machine::device::processor::perform, this)), LIB::mathematics::numbers::natural> cores;
					LIB::container::NAME_A <boost::thread *, boost::thread::id> cores;
					//LIB::NAME_A <LIB::machine::devices::processor::platform, mathematics::numbers::natural> threads;
					//LIB::mathematics::numbers::real _do (const LIB::machine::devices::processor::instruction) const;
				//	LIB::container::NAME_A <core, LIB::mathematics::numbers::natural> cores;
					
					//LIB::NAME_A <LIB::mathematics::numbers::real, mathematics::numbers::natural> _results;
					
					// Get a random processor from the available ones.
					// Returns 1 to maximum.
					LIB::tool::randomizer processor_randomizer;	// processors
					const LIB::mathematics::numbers::natural random_processor (void);
					//void dummy (void);
					
					// LIB::mathematics::numbers::natural get_next_instruction (void);
					// void increment_next_instruction (void);
					//boost::asio::io_service io;
					//boost::asio::deadline_timer * timer;
				
					//LIB::mathematics::numbers::natural timeout;
					
					// LIB::machine::devices::processor::queue _queue;
					//LIB::machine::devices::processor::instructions _queue;
					
				public:
					static const bool default_state;
					
					processor (const bool & /* Run. */ = default_state);
					~processor (void);
					
					// Get the number of processors (cores).
					const LIB::mathematics::numbers::natural size (void) const;
					//const LIB::mathematics::numbers::natural concurrency (void) const;
					
					const LIB::mathematics::numbers::natural queue_size (void) const;
					const bool queue_empty (void) const;
				//protected:
					//const instruction beginning (void);
					//const bool dequeue (void);
					const instruction beginning (void) const;
					const bool dequeue (void);
					const bool enqueue (const instructions &);
					const bool enqueue (const instruction &);
				//public:
					//const bool enqueue (const std::string &);	// enqueue evaluate load
					//const bool enqueue_file (const std::string &);
					//const bool enqueue_text (const std::string &);
					
					//void operator () (void);
					// Active state getter.
					const bool active (void) const;
					// Active state setter.
					const bool run (const bool & = true);
					//std::string execute (LIB::machine::devices::processor::instruction);
					
					
					// Queue instructions.
					//bool enqueue (LIB::machine::devices::processor::instructions);
					// bool enqueue (const LIB::machine::devices::processor::instruction &, LIB::mathematics::numbers::natural /* Processor index. */);
					//bool enqueue (const std::string & /* File name. */);
					// bool enqueue (const LIB::machine::devices::processor::instruction, LIB::language::devices::memory &);
					//void initialize (std::string);
					//LIB::mathematics::numbers::real Do (const LIB::machine::devices::processor::instruction) const;
					//LIB::NAME_V Do (const LIB::machine::devices::processor::instruction) const;
					//bool parse (const std::string);
					// Results:
					//bool result_exists (const LIB::mathematics::numbers::natural);
					//mathematics::numbers::real get_result (const LIB::mathematics::numbers::natural);
					//mathematics::numbers::real delete_result (const LIB::mathematics::numbers::natural);
					
					// The previous way:
					LIB::machine::device::memory _memory;
					// The new way?:
					//LIB::machine::cluster::entity memory;
				//	LIB::machine::entity memory;
				public:
					#include ".processor/postinnerindex.h++"
			};
/*		}
	}
}
*/
/*
LIB::Cluster::Platform::Platform (void)
{
	thread = NULL;
}

LIB::Cluster::Platform::Platform (void)
{
	delete thread;
}
*/

#include ".processor/postindex.h++"

//#endif
